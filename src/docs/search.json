[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "contents/functions.html",
    "href": "contents/functions.html",
    "title": "Functions",
    "section": "",
    "text": "download_rdocs()  source \n\nForces the update of the cached binary.\nUse this when the package version has been updated and a new updated release is available.\n\n\n\nrdocs::download_rdocs()"
  },
  {
    "objectID": "contents/functions.html#download_rdocs",
    "href": "contents/functions.html#download_rdocs",
    "title": "Functions",
    "section": "",
    "text": "download_rdocs()  source \n\nForces the update of the cached binary.\nUse this when the package version has been updated and a new updated release is available.\n\n\n\nrdocs::download_rdocs()"
  },
  {
    "objectID": "contents/functions.html#generate_docs",
    "href": "contents/functions.html#generate_docs",
    "title": "Functions",
    "section": "generate_docs",
    "text": "generate_docs\ngenerate_docs(files, folder_name = \"docs\", gh_url = \"\", run_examples = FALSE)  source \n\nGenerate a quarto website from lines starting with ### or /// that are right above function declarations.\nThe website folder is created in the current working directory.\nThe first line of the block is important, since the name of the variable will be used to group functions into the same one-worded section. This is useful, for example, when working using an OOP approach. For now, to avoid any bugs, it is important that all grouped functions are on the same file.\nThe user is free to create its headings, line breaks and make use of all other markdown utilities.\nAll R code identified by r code markdown blocks will be evaluated in a separate R session. If you don’t want a certain part of the code to be run, it will be needed to comment it or avoid the code block representation. If you don’t want to evaluate the code at all, use run_examples = FALSE, which is the default.\n\n\nArguments\n\nfiles\nThe files that will be used to create the .qmd documentation.\nfolder_name\nName of the folder which will store the website.\n\ngh_url\nA github url indicating where the documented files will be stored. It will create a link to the source code for each function. The default value will not create such links.\n\nrun_examples\nIf TRUE, All R code identified in an r code block will be evaluated in a separate R session. If you don’t want a certain part of the code to be run, it will be needed to comment it or avoid the r code representation in markdown.\n\n\n\n\nExamples\nrdocs::generate_docs(files = \"./rdocs/R/main.R\", folder_name = \"docs\", gh_url = \"https://github.com/daniellga/rdocs/tree/main/rdocs/R\", run_examples = FALSE)"
  },
  {
    "objectID": "contents/harray.html",
    "href": "contents/harray.html",
    "title": "HArray",
    "section": "",
    "text": "An array representation."
  },
  {
    "objectID": "contents/harray.html#new_from_values",
    "href": "contents/harray.html#new_from_values",
    "title": "HArray",
    "section": "new_from_values",
    "text": "new_from_values\nnew_from_values(arr: array, dtype: HDataType) -&gt; HArray  source \n\nCreates a new HArray from an R array.\n\n\nArguments\n\narr\nA double or complex array.\ndtype\nAn HDataType to indicate which type of HArray to be created.\nFor float dtypes, the atomic vector must be a double. For complex dtypes, a complex atomic vector.\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nHArray$new_from_values(arr, dtype)"
  },
  {
    "objectID": "contents/harray.html#len",
    "href": "contents/harray.html#len",
    "title": "HArray",
    "section": "len",
    "text": "len\nlen() -&gt; integer  source \n\nReturns the number of elements of this Harray.\n\n\nReturns\nAn integer.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$len()"
  },
  {
    "objectID": "contents/harray.html#shape",
    "href": "contents/harray.html#shape",
    "title": "HArray",
    "section": "shape",
    "text": "shape\nshape() -&gt; integers  source \n\nReturns the shape of this HArray.\n\n\nReturns\nA vector of integers.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$shape()"
  },
  {
    "objectID": "contents/harray.html#ndim",
    "href": "contents/harray.html#ndim",
    "title": "HArray",
    "section": "ndim",
    "text": "ndim\nndim() -&gt; integer  source \n\nReturns the number of dimensions of this HArray.\n\n\nReturns\nAn integer.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$ndim()"
  },
  {
    "objectID": "contents/harray.html#slice",
    "href": "contents/harray.html#slice",
    "title": "HArray",
    "section": "slice",
    "text": "slice\nslice(range: list[atomicvector]) -&gt; HArray  source \n\nSlices the HArray.\nThis operation has a COW (clone-on-write) behaviour. The created slice shares the inner data with the original array until one of them is modified.\n\n\nArguments\n\nrange\nA list of vectors of integers. The number of vectors in the list must be equal to the number of dimensions in the original HArray as they represent the slice information for each axis.\nEach vector must be composed of 3 elements: [start, end, step]. All 3 values can be positive or negative, although step can’t be 0.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$slice(list(c(0L, 2L, 1L), c(1L, 3L, 1L)))"
  },
  {
    "objectID": "contents/harray.html#print",
    "href": "contents/harray.html#print",
    "title": "HArray",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HArray.\nDifferently from R’s normal behaviour, print doesn’t return the value invisibly.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$print()\n\n# or similarly:\nprint(harray)"
  },
  {
    "objectID": "contents/harray.html#eq",
    "href": "contents/harray.html#eq",
    "title": "HArray",
    "section": "eq",
    "text": "eq\neq(other: HArray) -&gt; bool  source \n\nEquality with another HArray.\nThe comparison only checks if the dtype and the values are the same. To compare if the underlying data is the same in memory, check mem_adress.\n\n\nArguments\n\nother\nAn HArray.\n\n\n\n\nReturns\nA bool.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\n\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray2 = HArray$new_from_values(arr, dtype)\n\nharray1$eq(harray2) # TRUE\n\n# or similarly:\nharray1 == harray2"
  },
  {
    "objectID": "contents/harray.html#ne",
    "href": "contents/harray.html#ne",
    "title": "HArray",
    "section": "ne",
    "text": "ne\nne(other: HArray) -&gt; bool  source \n\nDifference with another HArray.\nThe comparison only checks if the dtype and the values are the same. To compare if the underlying data is the same in memory, check mem_adress.\n\nArguments\n\nother\nAn HArray.\n\n\n\nReturns\nA bool.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\n\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray2 = HArray$new_from_values(arr, dtype)\n\nharray1$ne(harray2) # FALSE\n\n# or similarly:\nharray1 != harray2"
  },
  {
    "objectID": "contents/harray.html#clone",
    "href": "contents/harray.html#clone",
    "title": "HArray",
    "section": "clone",
    "text": "clone\nclone() -&gt; HArray  source \n\nCreates a new HArray, with the underlying data pointing to the same place in memory.\n\nReturns\nAn HArray.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\nharray2 = harray1$clone()\nharray1 == harray2 # TRUE"
  },
  {
    "objectID": "contents/harray.html#collect",
    "href": "contents/harray.html#collect",
    "title": "HArray",
    "section": "collect",
    "text": "collect\ncollect() -&gt; array  source \n\nCreates an R array from an HArray. The type of the array created (double or complex) will depend on the HArray’s dtype.\n\nReturns\nAn array of type double or complex.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$collect()"
  },
  {
    "objectID": "contents/harray.html#dtype",
    "href": "contents/harray.html#dtype",
    "title": "HArray",
    "section": "dtype",
    "text": "dtype\ndtype() -&gt; HDataType  source \n\nGets the HArray’s dtype as an HDataType.\n\nReturns\nAn HDataType.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$dtype()"
  },
  {
    "objectID": "contents/harray.html#is_shared",
    "href": "contents/harray.html#is_shared",
    "title": "HArray",
    "section": "is_shared",
    "text": "is_shared\nis_shared() -&gt; bool  source \n\nChecks if the object is shared.\nSince HArray has a COW (clone-on-write) behaviour, this function is useful to check if a new object will be created or if the change will be done in-place.\n\n\nReturns\nA bool.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\nharray1$is_shared() # FALSE.\n\nharray2 = harray1$clone()\nharray$is_shared() # TRUE, HArray object shared with harray2."
  },
  {
    "objectID": "contents/harray.html#mem_adress",
    "href": "contents/harray.html#mem_adress",
    "title": "HArray",
    "section": "mem_adress",
    "text": "mem_adress\nmem_adress() -&gt; string  source \n\nThe memory adress of the first element of the inner array.\nThis is useful to check if different objects share the same underlying data.\n\n\nReturns\nA string.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$mem_adress()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "_docs",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]